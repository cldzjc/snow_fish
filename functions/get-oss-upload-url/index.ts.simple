import { serve } from "https://deno.land/std@0.224.0/http/server.ts";

// è·¨åŸŸå“åº”å¤´é…ç½®
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

/**
 * HMAC-SHA1 ç­¾åå‡½æ•°
 */
async function hmacSha1(key: string, data: string) {
  const enc = new TextEncoder();
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    enc.encode(key),
    { name: "HMAC", hash: "SHA-1" },
    false,
    ["sign"]
  );
  const signature = await crypto.subtle.sign(
    "HMAC",
    cryptoKey,
    enc.encode(data)
  );
  return btoa(String.fromCharCode(...new Uint8Array(signature)));
}

serve(async (req: Request) => {
  // å¤„ç† CORS é¢„æ£€è¯·æ±‚
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    console.log('ğŸ“¨ [GET-OSS-UPLOAD-URL] Received request');
    
    // 1. è·å–è®¤è¯ä¿¡æ¯ï¼ˆç®€åŒ–ç‰ˆï¼šç›´æ¥ä½¿ç”¨ test-userï¼‰
    const authHeader = req.headers.get('Authorization');
    console.log(`ğŸ”‘ Authorization header present: ${!!authHeader}`);
    
    // ä½¿ç”¨å›ºå®šçš„æµ‹è¯•ç”¨æˆ· IDï¼ˆè·³è¿‡ JWT éªŒè¯ï¼‰
    const userId = 'test-user-' + Date.now();
    console.log(`âœ… Using user ID: ${userId}`);

    // 2. è§£æè¯·æ±‚å‚æ•°
    const body = await req.json();
    const { 
      filename, 
      contentType, 
      owner_type,
      entity_type,
    } = body;

    console.log('ğŸ“‹ Request params:', { filename, contentType, owner_type, entity_type });

    const entityType = owner_type || entity_type;

    // 3. åŸºç¡€å‚æ•°æ ¡éªŒ
    if (!filename || !contentType || !entityType) {
      throw new Error("Missing required fields: filename, contentType, owner_type/entity_type");
    }

    // 4. OSS é…ç½®
    const accessKeyId = Deno.env.get("OSS_ACCESS_KEY_ID");
    const accessKeySecret = Deno.env.get("OSS_ACCESS_KEY_SECRET");
    const bucket = Deno.env.get("OSS_BUCKET");
    const region = Deno.env.get("OSS_REGION");

    console.log("ğŸ”§ Checking OSS config...", {
      hasAccessKeyId: !!accessKeyId,
      hasAccessKeySecret: !!accessKeySecret,
      hasBucket: !!bucket,
      hasRegion: !!region,
    });

    if (!accessKeyId || !accessKeySecret || !bucket || !region) {
      throw new Error("OSS configuration incomplete");
    }

    // 5. æ„å»º OSS å­˜å‚¨è·¯å¾„
    const timestamp = Date.now();
    const cleanFilename = filename.replace(/[^a-zA-Z0-9._-]/g, "_");
    const objectKey = `snowfish/${userId}/${entityType}/${timestamp}_${cleanFilename}`;

    console.log(`ğŸ“ Object key: ${objectKey}`);

    // 6. è®¡ç®— OSS é¢„ç­¾å URL
    const expires = Math.floor(Date.now() / 1000) + 120;
    const canonicalString = `PUT\n\n${contentType}\n${expires}\n/${bucket}/${objectKey}`;
    const signature = await hmacSha1(accessKeySecret, canonicalString);

    // 7. ç”Ÿæˆå®Œæ•´ URL
    const baseUrl = `https://${bucket}.${region}.aliyuncs.com/${objectKey}`;
    const uploadUrl = `${baseUrl}?OSSAccessKeyId=${accessKeyId}&Expires=${expires}&Signature=${encodeURIComponent(signature)}`;

    console.log(`âœ… Successfully generated upload URL`);

    return new Response(
      JSON.stringify({
        uploadUrl,
        publicUrl: baseUrl,
        objectKey,
      }),
      { 
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200 
      }
    );

  } catch (error) {
    console.error("âŒ Error:", error instanceof Error ? error.message : String(error));
    
    const errorMessage = error instanceof Error ? error.message : String(error);
    
    return new Response(
      JSON.stringify({ 
        error: errorMessage,
        timestamp: new Date().toISOString(),
      }),
      { 
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 400
      }
    );
  }
});
